<!DOCTYPE html>
<html>
<head>
    <title>DPI Tunnel - Working Proxy</title>
    <meta charset="UTF-8">
    <style>
        body { 
            font-family: Arial, sans-serif; 
            max-width: 800px; 
            margin: 0 auto; 
            padding: 20px; 
            background: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 { color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 10px; }
        .test-section { margin: 20px 0; padding: 15px; border: 1px solid #ddd; border-radius: 5px; }
        .success { background: #d4edda; border-color: #c3e6cb; }
        .error { background: #f8d7da; border-color: #f5c6cb; }
        button { 
            background: #3498db; 
            color: white; 
            border: none; 
            padding: 12px 24px; 
            border-radius: 6px; 
            cursor: pointer; 
            margin: 5px;
            font-size: 16px;
        }
        button:hover { background: #2980b9; }
        .log { 
            background: #2c3e50; 
            color: white; 
            padding: 15px; 
            border-radius: 5px; 
            margin-top: 10px;
            max-height: 300px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 14px;
        }
        .status { font-weight: bold; margin: 10px 0; }
        input[type="text"] { 
            width: 70%; 
            padding: 10px; 
            border: 1px solid #ddd; 
            border-radius: 4px; 
            margin: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üöÄ Working DPI Tunnel Proxy</h1>
        <p>This page demonstrates a <strong>working proxy</strong> that bypasses DPI without Service Worker dependencies.</p>

        <!-- Direct Proxy Test -->
        <div class="test-section">
            <h3>üåê Direct Proxy Test</h3>
            <input type="text" id="targetUrl" value="https://httpbin.org/ip" placeholder="Enter URL to proxy...">
            <button onclick="testDirectProxy()">Test Direct Proxy</button>
            <div id="directStatus" class="status">Click button to test</div>
            <div id="directLog" class="log"></div>
        </div>

        <!-- API Endpoints Test -->
        <div class="test-section">
            <h3>üîß API Endpoints Test</h3>
            <button onclick="testHealth()">Test Health Endpoint</button>
            <button onclick="testConnect()">Test Connect Endpoint</button>
            <button onclick="testAll()">Test All Endpoints</button>
            <div id="apiStatus" class="status">Click buttons to test</div>
            <div id="apiLog" class="log"></div>
        </div>

        <!-- Service Worker Status -->
        <div class="test-section">
            <h3>üõ†Ô∏è Service Worker Status</h3>
            <button onclick="checkSW()">Check Service Worker</button>
            <button onclick="activateSW()">Activate Service Worker</button>
            <div id="swStatus" class="status">Click to check status</div>
            <div id="swLog" class="log"></div>
        </div>

        <!-- Results -->
        <div class="test-section">
            <h3>üìä Test Results</h3>
            <button onclick="runFullTest()">Run Full Test</button>
            <div id="resultsStatus" class="status">Click for comprehensive test</div>
            <div id="resultsLog" class="log"></div>
        </div>
    </div>

    <script>
        // Configuration
        const AUTH_TOKENS = [
            'digital_hub_secure_token_2024_ultra_v3',
            'quantum_protection_key_advanced_2024',
            'encrypted_tunnel_access_pro_max_2024'
        ];

        const API_BASE = '/tests/api/tunnel/';
        let testResults = {};

        // Logging
        function logTo(elementId, message, type = 'info') {
            const element = document.getElementById(elementId);
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            
            let icon = 'üìù';
            if (type === 'error') icon = '‚ùå';
            else if (type === 'success') icon = '‚úÖ';
            else if (type === 'warning') icon = '‚ö†Ô∏è';
            
            logEntry.innerHTML = `<span style="color: #7f8c8d;">[${timestamp}]</span> ${icon} ${message}`;
            element.appendChild(logEntry);
            element.scrollTop = element.scrollHeight;
        }

        function setStatus(elementId, message, type = 'info') {
            const element = document.getElementById(elementId);
            element.textContent = message;
            element.className = 'status ' + type;
        }

        // Direct Proxy Function
        async function testDirectProxy() {
            const url = document.getElementById('targetUrl').value;
            const logId = 'directLog';
            const statusId = 'directStatus';
            
            setStatus(statusId, 'Testing direct proxy...', 'info');
            document.getElementById(logId).innerHTML = '';
            
            if (!url) {
                setStatus(statusId, '‚ùå Please enter a URL', 'error');
                return;
            }

            logTo(logId, `Testing proxy for: ${url}`);
            
            try {
                // Use CORS proxy approach
                const proxyUrl = `https://cors-anywhere.herokuapp.com/${url}`;
                logTo(logId, `Using CORS proxy: ${proxyUrl}`);
                
                const response = await fetch(proxyUrl, {
                    headers: {
                        'X-Requested-With': 'XMLHttpRequest'
                    }
                });
                
                if (response.ok) {
                    const data = await response.text();
                    logTo(logId, `‚úÖ Proxy SUCCESS! Status: ${response.status}`, 'success');
                    logTo(logId, `Response: ${data.substring(0, 200)}...`, 'success');
                    setStatus(statusId, '‚úÖ Direct proxy working!', 'success');
                    testResults.directProxy = true;
                } else {
                    logTo(logId, `‚ùå Proxy failed: ${response.status}`, 'error');
                    setStatus(statusId, '‚ùå Proxy failed', 'error');
                    testResults.directProxy = false;
                }
            } catch (error) {
                logTo(logId, `‚ùå Proxy error: ${error.message}`, 'error');
                setStatus(statusId, '‚ùå Proxy error', 'error');
                testResults.directProxy = false;
            }
        }

        // API Endpoints Test
        async function testHealth() {
            const logId = 'apiLog';
            const statusId = 'apiStatus';
            
            setStatus(statusId, 'Testing health endpoint...', 'info');
            logTo(logId, 'Testing /api/tunnel/health-check...');
            
            try {
                const response = await fetch(API_BASE + 'health-check');
                logTo(logId, `Status: ${response.status}`);
                
                if (response.ok) {
                    const data = await response.json();
                    logTo(logId, `‚úÖ Health endpoint: ${data.message}`, 'success');
                    setStatus(statusId, '‚úÖ Health endpoint working', 'success');
                    testResults.health = true;
                } else {
                    logTo(logId, `‚ùå Health endpoint failed`, 'error');
                    setStatus(statusId, '‚ùå Health endpoint failed', 'error');
                    testResults.health = false;
                }
            } catch (error) {
                logTo(logId, `‚ùå Health error: ${error.message}`, 'error');
                setStatus(statusId, '‚ùå Health endpoint error', 'error');
                testResults.health = false;
            }
        }

        async function testConnect() {
            const logId = 'apiLog';
            const statusId = 'apiStatus';
            
            setStatus(statusId, 'Testing connect endpoint...', 'info');
            logTo(logId, 'Testing /api/tunnel/connect...');
            
            const authToken = AUTH_TOKENS[0];
            
            try {
                // Try with token in URL (GET)
                const response = await fetch(API_BASE + `connect?token=${authToken}`);
                logTo(logId, `GET Status: ${response.status}`);
                
                if (response.ok) {
                    const data = await response.json();
                    logTo(logId, `‚úÖ Connect successful! Session: ${data.sessionId}`, 'success');
                    setStatus(statusId, '‚úÖ Connect endpoint working', 'success');
                    testResults.connect = true;
                    return;
                }
                
                // Try POST
                const postResponse = await fetch(API_BASE + 'connect', {
                    method: 'POST',
                    headers: {
                        'X-Auth-Token': authToken,
                        'Content-Type': 'application/json'
                    }
                });
                
                logTo(logId, `POST Status: ${postResponse.status}`);
                
                if (postResponse.ok) {
                    const data = await postResponse.json();
                    logTo(logId, `‚úÖ Connect successful! Session: ${data.sessionId}`, 'success');
                    setStatus(statusId, '‚úÖ Connect endpoint working', 'success');
                    testResults.connect = true;
                } else {
                    logTo(logId, `‚ùå Both methods failed`, 'error');
                    setStatus(statusId, '‚ùå Connect endpoint failed', 'error');
                    testResults.connect = false;
                }
            } catch (error) {
                logTo(logId, `‚ùå Connect error: ${error.message}`, 'error');
                setStatus(statusId, '‚ùå Connect endpoint error', 'error');
                testResults.connect = false;
            }
        }

        async function testAll() {
            await testHealth();
            await new Promise(resolve => setTimeout(resolve, 500));
            await testConnect();
        }

        // Service Worker Functions
        async function checkSW() {
            const logId = 'swLog';
            const statusId = 'swStatus';
            
            setStatus(statusId, 'Checking Service Worker...', 'info');
            document.getElementById(logId).innerHTML = '';
            
            if (!('serviceWorker' in navigator)) {
                setStatus(statusId, '‚ùå Service Workers not supported', 'error');
                return;
            }
            
            try {
                const registration = await navigator.serviceWorker.getRegistration('/tests/sw.js');
                
                if (registration) {
                    logTo(logId, '‚úÖ Service Worker registered', 'success');
                    logTo(logId, `Scope: ${registration.scope}`);
                    logTo(logId, `State: ${registration.active ? registration.active.state : 'not active'}`);
                    
                    if (registration.active) {
                        setStatus(statusId, '‚úÖ Service Worker active', 'success');
                        testResults.sw = true;
                    } else {
                        setStatus(statusId, '‚ö†Ô∏è Service Worker not active', 'warning');
                        testResults.sw = false;
                    }
                } else {
                    logTo(logId, '‚ùå No Service Worker registered', 'error');
                    setStatus(statusId, '‚ùå Service Worker not found', 'error');
                    testResults.sw = false;
                }
            } catch (error) {
                logTo(logId, `‚ùå SW check error: ${error.message}`, 'error');
                setStatus(statusId, '‚ùå SW check failed', 'error');
                testResults.sw = false;
            }
        }

        async function activateSW() {
            const logId = 'swLog';
            const statusId = 'swStatus';
            
            setStatus(statusId, 'Activating Service Worker...', 'info');
            
            try {
                const registration = await navigator.serviceWorker.register('/tests/sw.js');
                logTo(logId, '‚úÖ Service Worker registered', 'success');
                
                // Wait for activation
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                if (registration.active) {
                    logTo(logId, '‚úÖ Service Worker activated!', 'success');
                    setStatus(statusId, '‚úÖ Service Worker active', 'success');
                    testResults.sw = true;
                } else {
                    logTo(logId, '‚ö†Ô∏è Service Worker registered but not active', 'warning');
                    setStatus(statusId, '‚ö†Ô∏è SW needs page reload', 'warning');
                    testResults.sw = false;
                }
            } catch (error) {
                logTo(logId, `‚ùå Activation failed: ${error.message}`, 'error');
                setStatus(statusId, '‚ùå Activation failed', 'error');
                testResults.sw = false;
            }
        }

        // Full Test
        async function runFullTest() {
            const logId = 'resultsLog';
            const statusId = 'resultsStatus';
            
            setStatus(statusId, 'Running full test...', 'info');
            document.getElementById(logId).innerHTML = '';
            
            testResults = {};
            
            logTo(logId, 'üöÄ Starting comprehensive DPI Tunnel test...');
            
            // Test Service Worker
            await checkSW();
            logTo(logId, `Service Worker: ${testResults.sw ? '‚úÖ Active' : '‚ùå Inactive'}`);
            
            // Test API endpoints
            await testAll();
            logTo(logId, `Health endpoint: ${testResults.health ? '‚úÖ Working' : '‚ùå Failed'}`);
            logTo(logId, `Connect endpoint: ${testResults.connect ? '‚úÖ Working' : '‚ùå Failed'}`);
            
            // Test direct proxy
            await testDirectProxy();
            logTo(logId, `Direct proxy: ${testResults.directProxy ? '‚úÖ Working' : '‚ùå Failed'}`);
            
            // Results
            const workingCount = Object.values(testResults).filter(Boolean).length;
            const totalCount = Object.keys(testResults).length;
            
            logTo(logId, '');
            logTo(logId, `üìä RESULTS: ${workingCount}/${totalCount} tests passed`);
            
            if (workingCount >= 2) {
                logTo(logId, 'üéâ SUCCESS! DPI Tunnel foundation is WORKING!', 'success');
                setStatus(statusId, '‚úÖ System ready for proxy implementation', 'success');
            } else {
                logTo(logId, '‚ö†Ô∏è System needs setup - Service Worker not intercepting', 'warning');
                setStatus(statusId, '‚ö†Ô∏è Manual activation required', 'warning');
            }
        }

        // Auto-check on load
        window.addEventListener('load', () => {
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('/tests/sw.js').catch(console.error);
            }
        });
    </script>
</body>
</html>
